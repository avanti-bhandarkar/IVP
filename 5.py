# -*- coding: utf-8 -*-
"""IvP lab 5.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1tk_pymiQwbk3HaiUNYBz6CncJ3gdgQ7b
"""

#import libraries
import cv2
import numpy as np
import matplotlib.pyplot as plt

img= cv2.imread("1.tif",0) # Read the image

img_fft= np.fft.fft2(img, s=None, axes=(-2, -1), norm=None) # Apply FFT on original image
img_fft= np.fft.fftshift(img_fft) #Shifting the origin. Equvalent to multiplying by (-1)^x+y
img_abs= np.abs(img_fft) #Obtaining magnitude of the transformed image
img_phase= np.angle(img_fft) #Obtaining the Phase of the trasnformed image
img_log= np.log10(1+img_abs) # Performing Log transformation
m,n= img_fft.shape #Obtaining size (rows and cols)of the image

for i in range(m): #traverse through rows
  for j in range(m): #traverse through columns
    img[i][j] = ((-1)**(i+j)) #shifting origin based on the formula of multiplying by (-1)^x+y

#display all the obtained images
fig = plt.figure(figsize=(15,15),facecolor='w')
plt.subplot(2,2,1)
plt.imshow(img, cmap="gray")
plt.title("Original image")
plt.subplot(2,2,2)
plt.imshow(img_abs, "gray")
plt.title("Magnitude of the original image")
plt.subplot(2,2,3)
plt.imshow(img_phase, "gray")
plt.title("Phase of the original image")
plt.subplot(2,2,4)
plt.imshow(img_log, "gray")
plt.title("Log Transformation of the original image")

#Creating ideal lpf and ideal hpf masks
lpf= img.copy()
hpf= img.copy()
#Take radii d0= 10, 30,60,160,460

d0= int(input('Enter mask radii: '))

for i in range(m):
  for j in range(n):
    d1= np.sqrt((i-m//2)**2 +(j-n//2)**2)
    if d1>d0:
      lpf[i,j]=0
      hpf[i,j]=1
    else:
      lpf[i,j]= 1
      hpf[i,j]=0

img_lpf= img_fft*lpf # multiply lpf mask with the fft image
img_lpf= np.fft.fftshift(img_lpf)
img_new_lpf= np.real(np.fft.ifft2(img_lpf))

img_hpf= img_fft*hpf # multiply hpf mask with the fft image
img_hpf= np.fft.fftshift(img_hpf)
img_new_hpf= np.real(np.fft.ifft2(img_hpf))

#Plot orinal, low pass filtered and high pass filtered image
plt.figure(figsize=(20,20))
"""
plt.subplot(1,3,1)
plt.title("Original Image")
plt.imshow(img,cmap="gray")
"""
plt.subplot(1,2,1)
plt.title("Low Pass Filtered Image for radius = " +str(d0))
plt.imshow(img_new_lpf,cmap="gray")
plt.subplot(1,2,2)
plt.title("High Pass filtered image for radius = " +str(d0))
plt.imshow(img_new_hpf,cmap="gray", vmin=0, vmax=255)

"""##alternative"""

#define a function to apply low pass filter
def lpf(image,filter):
    frequency = np.fft.fft2(image) #convert image from time domain to frequency domain using fft
    freq_shift = np.fft.fftshift(frequency) #shift origin of the image

    rows, cols = image.shape #obtain rows and columns in the image
    rows2, cols2 = rows // 2, cols // 2 #define new values for rows and columns as half of the original values

    low_freq = freq_shift[rows2 - filter:rows2 + filter, cols2 - filter:cols2 + filter] #define as lpf as frequency shifted matrix with new values of rows and columns incremented/decremented by the filter size on each side 
    filtered = np.zeros(image.shape, dtype=np.complex_) #initialize a zero matrix with same shape as input image to contain filtered image
    filtered[rows2 - filter:rows2 + filter, cols2 - filter:cols2 + filter] = low_freq #fill the zero matrix with values from the new frequency shifted pixel values
    inverse_shift = np.fft.ifftshift(filtered) #shift the origin back
    inverse_fft = np.fft.ifft2(inverse_shift) #perform inverse fft to get image back into the time domain to plot it
    img_back = np.abs(inverse_fft) #take absolute values for each pixel

#display the original image and image obtained after low pass filtering
    plt.figure(figsize=(20,20))
    plt.subplot(2,2,1), plt.imshow(image, cmap='gray')
    plt.title('Original Image'), plt.xticks([]), plt.yticks([])
    plt.subplot(2,2,2), plt.imshow(img_back, cmap='gray')
    plt.title('Image after LPF using filter size = %i'%filter), plt.xticks([]), plt.yticks([])
    plt.show()

#define a function to apply high pass filter
def hpf(image,filter):

    frequency = np.fft.fft2(image) #convert image from time domain to frequency domain using fft
    freq_shift = np.fft.fftshift(frequency) #shift origin of the image

    rows, cols = image.shape #obtain rows and columns in the image
    crow, ccol = rows // 2, cols // 2 #define new values for rows and columns as half of the original values

    freq_shift[crow - filter:crow + filter, ccol - filter:ccol + filter] = 0 #equivalent to image-lpf = hpf as all low frequencies have been removed 
    inverse_shift = np.fft.ifftshift(filtered) #shift the origin back
    inverse_fft = np.fft.ifft2(inverse_shift) #perform inverse fft to get image back into the time domain to plot it
    img_back = np.abs(inverse_fft) #take absolute values for each pixel

#display the original image and image obtained after high pass filtering
    plt.figure(figsize=(20,20))
    plt.subplot(2,2,1), plt.imshow(image, cmap='gray')
    plt.title('Original Image'), plt.xticks([]), plt.yticks([])
    plt.subplot(2,2,2), plt.imshow(img_back, cmap='gray')
    plt.title('Image after HPF using filter size = %i'%filter), plt.xticks([]), plt.yticks([])
    plt.show()

#call the filter functions by giving input image and filter size as arguments 
hpf(img,120) #filter size = 120
lpf(img,10) #filter size = 60